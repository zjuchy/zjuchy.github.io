<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>S081 | ZJUCHY の blog</title><meta name="keywords" content="OS"><meta name="author" content="Haoyang Chen"><meta name="copyright" content="Haoyang Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ZJU_OS Linux Source Code S081 Note MIT 6.828 MIT 6.828 xv6 lab MIT 6.828 video S081 NoteLec 3OS organization12345sh echo find --&gt;lab1------------Unix接口 --&gt;how this works	OS------------Hard ware">
<meta property="og:type" content="article">
<meta property="og:title" content="S081">
<meta property="og:url" content="https://zjuchy.github.io/2022/02/02/S081/index.html">
<meta property="og:site_name" content="ZJUCHY の blog">
<meta property="og:description" content="ZJU_OS Linux Source Code S081 Note MIT 6.828 MIT 6.828 xv6 lab MIT 6.828 video S081 NoteLec 3OS organization12345sh echo find --&gt;lab1------------Unix接口 --&gt;how this works	OS------------Hard ware">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/02/02/rLZKxailymv5bCH.png">
<meta property="article:published_time" content="2022-02-02T11:59:02.000Z">
<meta property="article:modified_time" content="2022-02-02T11:59:15.321Z">
<meta property="article:author" content="Haoyang Chen">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/02/rLZKxailymv5bCH.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zjuchy.github.io/2022/02/02/S081/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'S081',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-02 19:59:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/02/02/rLZKxailymv5bCH.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZJUCHY の blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">S081</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-02-02T11:59:02.000Z" title="Created 2022-02-02 19:59:02">2022-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-02-02T11:59:15.321Z" title="Updated 2022-02-02 19:59:15">2022-02-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="S081"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://gitee.com/zjusec/os21fall">ZJU_OS</a></p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source">Linux Source Code</a></p>
<p><a target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec01-introduction-and-examples">S081 Note</a></p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">MIT 6.828</a></p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf">MIT 6.828 xv6 lab</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19k4y1C7kA?from=search&seid=747757229768034336">MIT 6.828 video</a></p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">S081</a></p>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Lec-3"><a href="#Lec-3" class="headerlink" title="Lec 3"></a>Lec 3</h3><h4 id="OS-organization"><a href="#OS-organization" class="headerlink" title="OS organization"></a>OS organization</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh echo find --&gt;lab1</span><br><span class="line">------------Unix接口 --&gt;how <span class="keyword">this</span> works</span><br><span class="line">	OS</span><br><span class="line">------------</span><br><span class="line">Hard ware</span><br></pre></td></tr></table></figure>

<h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>it has multiple applications, it has strong isolation between different applications.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh | echo | find  |--&gt;the isolation between different applications.</span><br><span class="line">__________________ --&gt;the isolation between OS <span class="keyword">and</span> applications.</span><br><span class="line">------------Unix接口 </span><br><span class="line">      OS</span><br></pre></td></tr></table></figure>

<h5 id="Unix-interface"><a href="#Unix-interface" class="headerlink" title="Unix interface"></a>Unix interface</h5><ul>
<li><p>abstract the Hard Ware resources</p>
</li>
<li><p>process: instead of CPU . </p>
<ul>
<li>OS provide process as a way to CPU 不是直接访问CPU,而是通过进程的方法</li>
</ul>
</li>
<li><p>exec : instead of memory</p>
<ul>
<li>是内存镜像,一个CPU抽象成一个进程,RISC-V has four cores 如果有多个进程,则会通过时间复用在不同进程上,100 ms运行,停止,卸载,在加载下一个程序进程,运行100 ms,多个进程不可同时使用相同的CPU</li>
<li>操作系统提供内存隔离,不能直接访问物理内存?虚拟内存?</li>
</ul>
</li>
<li><p>files :instead of disk block</p>
<ul>
<li>访问存储系统只能通过文件,然后OS map file in disk blocks and make sure disk blocks will only show up in one file .文件抽象接口存在strong isolation</li>
</ul>
</li>
</ul>
<p>cache affinity 缓存亲和性</p>
<p>enforce both multiplexing and strong memory isolation(有复用,有隔离性)</p>
<p><code>proc.c</code> check the OS multiplex process </p>
<p>app can’t break out of isolation (into Kernel) : so strong isolation between app and OS</p>
<blockquote>
<p> so Hard ward support: 所有可以运行多应用程序的处理器都支持内核模式和虚拟内存(两个strong isolation)</p>
<ul>
<li><strong>User\kernel mode(管理员模式)</strong></li>
<li><strong>page table(virtual memory)</strong></li>
</ul>
</blockquote>
<h4 id="Kernel-x2F-user-mode"><a href="#Kernel-x2F-user-mode" class="headerlink" title="Kernel&#x2F;user mode"></a>Kernel&#x2F;user mode</h4><ul>
<li><p>User mode : unprivileged instructions (such as add sub jal)</p>
</li>
<li><p>kernel mode : privileged instructions (setting up table register, setting disabling clock interrupts)</p>
</li>
</ul>
<blockquote>
<p>处理器有标志位: 0 kernel mode and 1 user mode 所以解码文件的时候,对于privileged instructions如果标志位是1则拒绝执行该指令.(divide zero instruction)</p>
<p>BIOS先启动,再启动OS</p>
</blockquote>
<h4 id="Page-Table-virtual-memory"><a href="#Page-Table-virtual-memory" class="headerlink" title="Page Table(virtual memory)"></a>Page Table(virtual memory)</h4><p>every process has own table page: memory isolation</p>
<p>ls程序运行的时候，会调用read&#x2F;write系统调用；Shell程序会调用fork或者exec系统调用</p>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJRnQQkLpnAR3xcpBOe%2F-MJSMyew-n45ZU01CtUw%2Fimage.png?alt=media&token=0a1dab14-28d2-4c5e-a044-0cc6902140b3" alt="img"></p>
<h4 id="Entering-Kernel"><a href="#Entering-Kernel" class="headerlink" title="Entering Kernel"></a>Entering Kernel</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ecall &lt;n&gt; --&gt;n is system call number</span><br><span class="line">    <span class="comment">//每次调用ecall，application会进入内核特定的地方</span></span><br><span class="line">fork() --&gt;ecall n --|--&gt;kernel syscall--&gt;Sys_fork()</span><br><span class="line">    <span class="comment">//user 通过ecall调用kernel里的syscall,而不是直接调用kernel里的fork</span></span><br><span class="line">  	<span class="comment">//这里的n是存在a0里，Sys 查看a0 ，然后调用Sys_fork()</span></span><br><span class="line">write() --&gt;ecall n--|--&gt;sys_write</span><br><span class="line">  	<span class="comment">//write 同理</span></span><br></pre></td></tr></table></figure>

<p>Kernel : trusted computing base  必须正确,没有任何bug(不然会成为漏洞,被打破), 视用户代码作为有害的,</p>
<p>File Server 可以在用户mode进行(但它是内核代码?)为了尽可能减少内核的代码量 </p>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJX963vbIPHKetjGrZN%2F-MJXQ4BUMhscu13BPT1v%2Fimage.png?alt=media&token=92170af8-075f-4d3a-be59-d50852bba34c" alt="img"></p>
<h4 id="Monolithic-Kernel-Design"><a href="#Monolithic-Kernel-Design" class="headerlink" title="Monolithic Kernel Design"></a>Monolithic Kernel Design</h4><p>整个操作系统代码都运行在kernel mode</p>
<ul>
<li>因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能</li>
<li>从安全的角度来说，在内核中有大量的代码是宏内核的缺点</li>
</ul>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJbSdGiMLB2VO1kFUtK%2F-MJbYtEBzpGpaCAFdeZk%2Fimage.png?alt=media&token=2e005add-cd05-4201-9fab-5149d38765ab" alt="img"></p>
<h4 id="Micro-Kernel-Design"><a href="#Micro-Kernel-Design" class="headerlink" title="Micro Kernel Design"></a>Micro Kernel Design</h4><p>(系统调用次数增加)(先进入IPC,再到FS,再回IPC,再进shell),难以获得高性能</p>
<ul>
<li><p>在user&#x2F;kernel mode反复跳转带来的性能损耗</p>
</li>
<li><p>在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能</p>
</li>
</ul>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJbSdGiMLB2VO1kFUtK%2F-MJbcquRoZotyofyd2sh%2Fimage.png?alt=media&token=71f32a22-7654-4116-9dee-a40537c01a13" alt="img"></p>
<h4 id="Xv6-and-qemu"><a href="#Xv6-and-qemu" class="headerlink" title="Xv6 and qemu"></a>Xv6 and qemu</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) ➜  xv6-labs-2020 git:(syscall) ✗ make qemu</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">init: starting sh</span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash">-kernel：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-m：这里传递的是RISC-V虚拟机将会使用的内存数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-smp：这里传递的是虚拟机可以使用的CPU核数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件</span></span><br></pre></td></tr></table></figure>

<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJgYxe3Ki7wfpMQgXe-%2F-MJgjgTH1N3waADySy12%2Fimage.png?alt=media&token=a66a77d5-f019-4ddb-921e-1a74fd055567" alt="img"></p>
<ul>
<li><p>4个核：U54 Core 1-4</p>
</li>
<li><p>L2 cache：Banked L2</p>
</li>
<li><p>连接DRAM的连接器：DDR Controller</p>
</li>
<li><p>各种连接外部设备的方式，比如说UART0，一端连接了键盘，另一端连接了terminal。</p>
</li>
<li><p>以及连接了时钟的接口：Clock Generation</p>
</li>
</ul>
<h3 id="Lec-4"><a href="#Lec-4" class="headerlink" title="Lec 4"></a>Lec 4</h3><p>virtual memory : VPN+offset   <u>map</u> to PPN+offset</p>
<p>虚拟内存可以保护每个进程的物理地址,提高性能</p>
<h4 id="Address-Spaces"><a href="#Address-Spaces" class="headerlink" title="Address Spaces"></a>Address Spaces</h4><p>memory isolation</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ld $<span class="number">7</span>,a0</span><br><span class="line">CPU---&gt;<span class="function">memory manager <span class="title">unit</span><span class="params">(MMU)</span>---&gt; mem</span></span><br><span class="line"><span class="function"><span class="comment">//cpu输出的是virtual memory 到MMU中</span></span></span><br><span class="line"><span class="function"><span class="comment">//MMU输入VA,输出PA(physical memory)到mem中,MMU有table page</span></span></span><br><span class="line"><span class="function"><span class="comment">//cpu存在cache储存mmu的地址(satp),当操作系统切换app时,satp里的内容会变化,所以echo与cat虚拟内存不同,every app has his own map,satp映射是有2^27个index</span></span></span><br></pre></td></tr></table></figure>

<p>假设Page Table的地址是0x10，SATP寄存器（在CPU中）存的就是0x10这个地址，page table保存在cache中，MMU只是会去查看page table</p>
<p>将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单，内核会写SATP寄存器，写SATP寄存器是一条特殊权限指令，只有运行在kernel mode的代码可以更新这个寄存器</p>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKKjB2an4WcuUmOlE__%2F-MKONgZr-r8W5uRpknWQ%2Fimage.png?alt=media&token=30b484c3-ca16-43f7-a457-aba16023ef0d" alt="img"></p>
<h4 id="Page-Table-RISC-V"><a href="#Page-Table-RISC-V" class="headerlink" title="Page Table(RISC-V)"></a>Page Table(RISC-V)</h4><p>one page 4 kb —&gt; 4096 bytes</p>
<p>Virtual Memory：27 bits are index and 12 bits are offset</p>
<p>We can get the physical’s page number from 27bits ,which is continuous space of size 4096. And that’s why it must have 12 bits offset. (就是27位查找page，然后一个page对应的是一个大小为4096字节的连续的空间)</p>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKKjB2an4WcuUmOlE__%2F-MKP01z4cRvXo7hN7r3Z%2Fimage.png?alt=media&token=eeb0d866-b4b7-4c8e-8d4b-13ffa7e72a56" alt="img"></p>
<p>risc-v’s Physical Memory has 56 bytes (12 bytes is offset, 44 bytes is Physical Page Number)</p>
<p>Virtual Memory is up to 2^27, physical memory is up to 2^56. Multiple process can exhaust virtual memory without using up all the physical memory. </p>
<p>Page Directory is 4096 bytes. One PTE is 8 bytes，so 4096&#x2F;8&#x3D;512（it has 512 PTEs) </p>
<blockquote>
<p>图上只显示了44+10&#x3D;54位，实际上就是64bits 一条</p>
</blockquote>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKKjB2an4WcuUmOlE__%2F-MKQ-XlNXF40rUbmymdz%2Fimage.png?alt=media&token=7df83c67-2357-45dd-9a0f-1fae410c7ef9" alt="img"></p>
<p>PTE（Page Table Entry）in Directory is 8 Bytes, one page needs 2^27 PTE, but L1,L2,L3 only need 3*2^9 PTE</p>
<p><img src="https://mit-public-courses-cn-translatio.gitbook.io/~/files/v0/b/gitbook-28427.appspot.com/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MKQ3oLlaUanoFBXrOu6%2F-MKVD5xKfkcui0853IM6%2Fimage.png?alt=media&token=d4198af2-e6ac-4af4-b1b2-cf600a7bebd1" alt="img"></p>
<ul>
<li>第一个标志位是Valid。如果Valid bit位为1，那么表明这是一条合法的PTE，你可以用它来做地址翻译。对于刚刚举得那个小例子（应用程序只用了1个page的例子），我们只使用了3个page directory，每个page directory中只有第0个PTE被使用了，所以只有第0个PTE的Valid bit位会被设置成1，其他的511个PTE的Valid bit为0。这个标志位告诉MMU，你不能使用这条PTE，因为这条PTE并不包含有用的信息。</li>
<li>下两个标志位分别是Readable和Writable。表明你是否可以读&#x2F;写这个page。</li>
<li>Executable表明你可以从这个page执行指令。</li>
<li>User表明这个page可以被运行在用户空间的进程访问</li>
</ul>
<h4 id="Translation-Lookaside-Buffer"><a href="#Translation-Lookaside-Buffer" class="headerlink" title="Translation Lookaside Buffer"></a>Translation Lookaside Buffer</h4><p>TLB (translation look-aside buffer) 保存了page table entries and PTE entries</p>
<p>TLB: map(VA,PA) TLB切换页表,<code>sfence_vma</code></p>
<p>kernel stack 位于内存较高的位置,原因是有一个没有映射的守护也在它下面,所以Kstack 下面的PTE没有有效位,所以一旦一处就会报错,不是修改其他内存</p>
<p><img src="https://pic4.zhimg.com/80/v2-b3cb5245f66563d1fdf844b19f509dab_720w.jpg" alt="img"></p>
<h4 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h4><p>它被映射到虚拟地址空间的顶端</p>
<p><strong>保护页guard page</strong>。保护页的PTE_V是无效的，访问它会引发缺页错误的异常，从而陷入内核，这样的设计可以防止内核栈溢出。</p>
<h4 id="xv6-vmcode-layout"><a href="#xv6-vmcode-layout" class="headerlink" title="xv6 vmcode+layout"></a>xv6 vmcode+layout</h4><p>layout of the kernel address space and user address space(空间布局)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> b kvminithart</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout split <span class="comment"># 得到c与汇编的窗口哦</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout src <span class="comment">#得到c</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout asm <span class="comment">#得到汇编</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tui <span class="built_in">enable</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout asm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout reg</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> foces reg <span class="comment">#可以滚动reg窗</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> info breakpoints <span class="comment">#查看断点信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> info reg <span class="comment">#查看寄存器信息</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Lec-5"><a href="#Lec-5" class="headerlink" title="Lec 5"></a>Lec 5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global sum_to</span><br><span class="line">;.global可以保证这些函数可以在其他地方调用</span><br><span class="line">;.text表示这是代码</span><br></pre></td></tr></table></figure>

<h4 id="tui"><a href="#tui" class="headerlink" title="tui"></a>tui</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apropos tui <span class="comment"># 查看所有tui命令行</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tui <span class="built_in">enable</span>  <span class="comment">#  打开源代码展示窗口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout asm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout reg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> focus asm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> focus reg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> layout split</span></span><br></pre></td></tr></table></figure>

<h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i frameStack level 0, frame at 0x0: 						 #这是调用栈的最底层 pc = 0x8000047e; saved pc = &lt;not saved&gt; #Performance count Outermost frame: outermost Arglist at unknown address.							#参数的起始地址 Locals at unknown address, Previous frame&#x27;s sp in spCould not fetch register &quot;ustatus&quot;; remote failure reply &#x27;E14&#x27;$ i args$ bt # back trace 可以看到从当前调用栈开始的所有Stack Frame$ frame 0</span><br></pre></td></tr></table></figure>

<h4 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h4><p>a0,a1都是可以返回函数返回值的</p>
<p>s1与s2-s11分开是因为在压缩指令模式s1可用,而s2-s11不可用</p>
<ul>
<li><p>Caller Saved寄存器在函数调用的时候不会保存</p>
</li>
<li><p>Callee Saved寄存器在函数调用的时候会保存</p>
</li>
</ul>
<blockquote>
<p>Callee saved由调用者保存并恢复</p>
</blockquote>
<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>每执行一次函数调用就会产生一个Stack Frame。</p>
<p>堆栈是向下扩展的,因此堆栈的运算一般是相减的</p>
<blockquote>
<p>add sp sp -16</p>
<p>#创建4格的空间</p>
</blockquote>
<p>fp: top of current frame (返回地址与)指向当前Stack Frame的顶部</p>
<p>sp: bottom of stack. 代表了当前Stack Frame的位置</p>
<p>Stack Frame有两件事情是确定的：</p>
<ul>
<li><p>Return address总是会出现在Stack Frame的第一位</p>
</li>
<li><p>指向前一个Stack Frame的指针也会出现在栈中的固定位置</p>
</li>
</ul>
<p>我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。</p>
<p>Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame , so ASM Function在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epollgue。这就是一个汇编函数通常的样子。</p>
<ul>
<li><p>function prologue</p>
</li>
<li><p>body</p>
</li>
<li><p>epilogue</p>
</li>
</ul>
<p>ra寄存器是64bit（8字节）。这里的习惯是用要存16字节. Return address和指向上一个Stack Frame的地址，只不过我们这里没有存指向上一个Stack Frame的地址。如果你看kernel.asm，你可以发现16个字节通常就是编译器的给的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum_to: #it&#x27;s a leaf function	retsum_double:	addi sp sp -16 #prologue	sd ra 0(sp)		 #prologue	call sum_to	ld ra 0(sp)		 #Epllogue	addi sp sp 16  #Epllogue	ret</span><br></pre></td></tr></table></figure>

<h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p>struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，<strong>但是里面的不同字段的类型可以不一样</strong>!!    </p>
<p>可以作为参数</p>
<h3 id="Lec-6"><a href="#Lec-6" class="headerlink" title="Lec 6"></a>Lec 6</h3><h4 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h4><p><strong>用户空间和内核空间的切换通常被称为trap</strong></p>
<ul>
<li><p>程序执行系统调用</p>
</li>
<li><p>程序出现了类似page fault、运算时除以0的错误</p>
</li>
<li><p>一个设备触发了中断使得当前程序运行需要响应内核设备驱动</p>
</li>
</ul>
<p>很多应用程序，要么因为系统调用，要么因为page fault，都会频繁的切换到内核中。所以，trap机制要尽可能的简单，这一点非常重要</p>
<p>32个用户寄存器</p>
<ul>
<li><p>程序计数器（Program Counter Register）</p>
</li>
<li><p>表明当前mode的标志位，这个标志位表明了当前是supervisor mode还是user mode。当我们在运行Shell的时候，自然是在user mode。</p>
</li>
<li><p>satp寄存器<strong>存放指向页表的指针</strong>,指向<strong>page table的物理内存地址</strong></p>
</li>
<li><p>stvec 处理中断的地址,它指向了内核中处理trap的指令的起始地址</p>
</li>
<li><p>sepc : trap期间保存程序计数器</p>
</li>
<li><p>sscratch 系统调度时计算机正在使用的状态(state of running machine at the time of the system call)</p>
</li>
</ul>
<p>在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。</p>
<ul>
<li><p>首先，我们需要<strong>保存32个用户寄存器</strong>。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。</p>
</li>
<li><p><strong>程序计数器也需要在某个地方保存</strong>，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。</p>
</li>
<li><p>我们需要将<strong>mode改成supervisor mode</strong>，因为我们想要使用内核中的各种各样的特权指令。</p>
</li>
<li><p>SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要<strong>将SATP指向kernel page table</strong></p>
</li>
<li><p>我们需要将<strong>堆栈寄存器指向位于内核的一个地址</strong>，因为我们需要一个堆栈来调用内核的C函数。</p>
</li>
<li><p>一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的C代码。</p>
</li>
</ul>
<p>user mode –&gt;kernel </p>
<p><strong>mode flag control</strong></p>
<p>当我们在用户空间时，这个标志位对应的是user mode，当我们在内核空间时，这个标志位对应supervisor mode</p>
<h5 id="supervisor-mode"><a href="#supervisor-mode" class="headerlink" title="supervisor mode"></a>supervisor mode</h5><ul>
<li>R&#x2F;W CTL REGS (read&#x2F;write and control register)</li>
</ul>
<p>读写SATP寄存器，也就是page table的指针；STVEC，也就是处理trap的内核指令地址；SEPC，保存当发生trap时的程序计数器；SSCRATCH等等。在supervisor mode你可以读写这些寄存器，而用户代码不能做这样的操作。</p>
<ul>
<li>use PTES W&#x2F;O PTE_U ?</li>
</ul>
<p>可以使用PTE_U标志位为0的PTE.当<strong>PTE_U标志位为1</strong>的时候，表明用户代码<strong>可以使用</strong>这个页表；如果这个标志位为0，则只有supervisor mode可以使用这个页表。</p>
<p>supervisor mode中的代码并不能读写任意物理地址。在supervisor mode中，就像普通的用户代码一样，也需要<strong>通过page table来访问内存</strong>。如果一个虚拟地址并不在当前由SATP指向的page table中，又或者SATP指向的page table中PTE_U&#x3D;1，那么supervisor mode不能使用那个地址。所以，即使我们在supervisor mode，我们还是受限于当前page table设置的虚拟地址。</p>
<h4 id="Process-of-Trap"><a href="#Process-of-Trap" class="headerlink" title="Process of Trap"></a>Process of Trap</h4><p>页表条目(page table entry <em>PTE</em>)</p>
<ul>
<li><p>write通过执行ECALL指令来执行系统调用。ECALL指令会切换到具有supervisor mode的内核中。</p>
</li>
<li><p>在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做uservec,是内核代码trampoline.s文件的一部分。所以执行的第一个代码就是这个uservec汇编函数</p>
</li>
<li><p>汇编函数中，代码执行跳转到了由C语言实现的函数usertrap中，这个函数在trap.c中。</p>
</li>
<li><p>在usertrap这个C函数中，我们执行了一个叫做syscall的函数。根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。对于我们来说，这个函数就是sys_write</p>
</li>
<li><p>sys_write会将要显示数据输出到console上，当它完成了之后，它会返回给syscall函数。</p>
</li>
<li><p>在ECALL之后中断了用户代码的执行，为了用户空间的代码恢复执行，需要做一系列的事情。在syscall函数中，会调用一个函数叫做usertrapret，它也位于trap.c中，这个函数完成了部分方便在C代码中实现的返回到用户空间的工作。</p>
</li>
<li><p>部分工作通过汇编语言实现，并且存在于trampoline.s文件中的userret函数中。</p>
</li>
<li><p>汇编函数中会调用机器指令返回到用户空间，并且恢复ECALL之后的用户程序的执行。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> b 0xde4 <span class="comment">#make break point at ecall$ c$ delete 1 #删除1号断点$ print $pc #打印当前位置$ info reg$ print/x $satp</span></span></span><br></pre></td></tr></table></figure>

<h4 id="before-ecall"><a href="#before-ecall" class="headerlink" title="before ecall"></a>before ecall</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl-a+cinfo mem打印完整的页表</span><br></pre></td></tr></table></figure>

<p>程序计数器（Program Counter）</p>
<p>Shell是一个非常小的程序，这6条映射关系是有关Shell的指令和数据，以及一个无效的page用来作为<strong>guard page</strong>，以防止Shell尝试使用过多的stack page. 在attr这一列它并没有设置u标志位（第三行）。attr这一列是PTE的标志位，第三行的标志位是<strong>rwx</strong>表明这个page可以读，可以写，也可以执行指令。之后的是<strong>u标志位</strong>，它表明<strong>PTE_u标志位是否被设置，用户代码只能访问u标志位设置了的PTE</strong>。再下一个标志位我也不记得是什么了（注，从4.3可以看出，这个标志位是Global）。再下一个标志位是<strong>a（Accessed）</strong>，表明这条PTE是不是被<strong>使用过</strong>。再下一个标志位<strong>d（Dirty）</strong>表明这条PTE是不是被<strong>写过</strong>。</p>
<p>最后两条PTE的<strong>虚拟地址</strong>非常大，非常接近虚拟地址的顶端，如果你读过了XV6的书，你就知道这两个page分别是<strong>trapframe page和trampoline page</strong>。你可以看到，它们都没有设置u标志，所以用户代码不能访问这两条PTE。一旦我们进入到了supervisor mode，我们就可以访问这两条PTE了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将每个虚拟地址映射到一个物理地址，页表会以某种形式的表项来保存这种映射关系，这种表项我们称之为页表条目PTE（Page Table Entry）。</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>物理内存吃紧的时候，可能会通过将一些内存写入到磁盘来，同时将相应的PTE设置成无效，来释放物理内存page。你可以想到，这里有很多策略可以让操作系统来挑选哪些page可以释放, 我们可以查看a标志位来判断这条PTE是否被使用过，如果它没有被使用或者最近没有被使用，那么这条PTE对应的page适合用来保存到磁盘中。类似的，d标志位告诉内核，这个page最近被修改过。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/3i 0xde4# 打印三个instructions</span><br></pre></td></tr></table></figure>

<h4 id="after-ecall"><a href="#after-ecall" class="headerlink" title="after ecall"></a>after ecall</h4><p>csrrw 指令 : 这条指令交换了寄存器a0和sscratch的内容。这个操作超级重要，它回答了这个问题，内核的trap代码如何能够在不使用任何寄存器的前提下做任何操作。这条指令将a0的数据保存在了sscratch中，同时又将sscratch内的数据保存在a0中。<strong>之后内核就可以任意的使用a0寄存器了。</strong></p>
<p>地址0x3ffffff000，也就是上面page table输出的最后一个page，这是trampoline page。我们现在正在trampoline page中执行程序，这个page包含了内核的trap处理代码。<strong>ecall并不会切换page table</strong>，这是ecall指令的一个非常重要的特点。所以这意味着，<strong>trap处理代码必须存在于每一个user page table中</strong>。因为ecall并不会切换page table，我们需要在user page table中的某个地方来执行最初的内核代码。而这个trampoline page，是由内核小心的映射到每一个user page table中，以使得当我们仍然在使用user page table时，内核在一个地方能够执行trap机制的最开始的一些指令。</p>
<p>这里的控制是通过STVEC寄存器完成的，这是一个只能在supervisor mode下读写的特权寄存器。在从内核空间进入到用户空间之前，内核会设置好STVEC寄存器指向内核希望trap代码运行的位置。内核已经事先设置好了STVEC寄存器的内容为0x3ffffff000，这就是trampoline page的起始位置。STVEC寄存器的内容，就是在ecall指令执行之后，我们会在这个特定地址执行指令的原因。</p>
<blockquote>
<p>即使trampoline page是在用户地址空间的user page table完成的映射，用户代码不能写它，因为这些page对应的PTE并没有设置PTE_u标志位。这也是为什么trap机制是安全的。</p>
</blockquote>
<p>我们是通过ecall走到trampoline page的，而ecall实际上只会改变三件事情：</p>
<ul>
<li><p>ecall将代码从user mode改到supervisor mode。</p>
</li>
<li><p>ecall将程序计数器的值保存在了SEPC寄存器。我们可以通过打印程序计数器看到这里的效果，尽管其他的寄存器还是还是用户寄存器，但是这里的<strong>程序计数器明显已经不是用户代码的程序计数器</strong>。这里的程序计数器是<strong>从STVEC寄存器拷贝过来的值</strong>。我们也可以打印SEPC（Supervisor Exception Program Counter）寄存器，这是ecall保存用户程序计数器的地方。这个寄存器里面有熟悉的地址0xde6，这是ecall指令在用户空间的地址。所以ecall至少保存了程序计数器的数值。</p>
</li>
<li><p>ecall会跳转到STVEC寄存器指向的指令。!!!!!在中断时，stvec指向处理的代码的位置，在trampoline.asm中可以找到</p>
</li>
</ul>
<blockquote>
<p>ecall只会更新<strong>CPU中的mode标志位为supervisor</strong>，并且设置程序计数器成STVEC寄存器内的值。在进入到用户空间之前，内核会将trampoline page的地址存在STVEC寄存器中。所以ecall的下一条指令的位置是STVEC指向的地址，也就是trampoline page的起始地址。（注，实际上<strong>ecall是CPU的指令</strong>，自然在gdb中看不到具体内容）</p>
</blockquote>
<h4 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h4><p>现在程序位于trampoline page的起始，也是uservec函数的起始, 第一件事情就是保存寄存器的内容. RISC-V中，supervisor mode下的代码不允许直接访问物理内存。所以我们只能使用page table中的内容，但是从前面的输出来看，page table中也没有多少内容。</p>
<p>XV6在每个user page table映射了trapframe page</p>
<h4 id="csrrw"><a href="#csrrw" class="headerlink" title="csrrw"></a>csrrw</h4><p>这个指令交换了a0和sscratch两个寄存器的内容。XV6会将CPU核的编号也就是hartid保存在tp寄存器</p>
<p>trampoline page在user page table中的映射与kernel page table中的映射是完全一样的。这两个page table中其他所有的映射都是不同的，只有trampoline page的映射是一样的</p>
<h3 id="Let-8"><a href="#Let-8" class="headerlink" title="Let 8"></a>Let 8</h3><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code 3"></a>Code 3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>S081 <span class="number">2020</span> Lecture <span class="number">3</span>: OS organizationLecture Topic:  OS design    system calls    micro/monolithic kernel  First system call in xv6OS picture  apps: sh, echo, ...  <span class="function">system call <span class="title">interface</span> <span class="params">(open, close,...)</span>        OS  Goal of OS  run multiple applications  isolate them  multiplex them  shareStrawman design: No OS  Application directly interacts with hardware    CPU cores &amp; registers    DRAM chips    Disk blocks    ...  OS library perhaps abstracts some of itStrawman design <span class="keyword">not</span> conducive to multiplexing  each app periodically must give up hardware  BUT, weak isolation    app forgets to give up, no other app runs    apps has end-less loop, no other app runs    you cannot even kill the badly app from another app  but used by real-time OSes    &quot;cooperative scheduling&quot;Strawman design <span class="keyword">not</span> conducive to memory isolation  all apps share physical memory  one app can overwrites another apps memory  one app can overwrite OS libraryUnix interface conducive to OS goals  abstracts the hardware in way that achieves goals  <span class="title">processes</span> <span class="params">(instead of cores)</span>: fork     OS transparently allocates cores to processes       Saves <span class="keyword">and</span> restore registers     Enforces that processes give them up       Periodically re-allocates cores       <span class="title">memory</span> <span class="params">(instead of physical memory)</span>: exec     Each process has its &quot;own&quot; memory     OS can decide where to place app in memory     OS can enforce isolation between memory of different apps     OS allows storing image in file system  <span class="title">files</span> <span class="params">(instead of disk blocks)</span>     OS can provide convenient names     OS can allow sharing of files between processes/users  <span class="title">pipes</span> <span class="params">(instead of shared physical mem)</span>     OS can stop sender/receiver  OS must be defensive  an application shouldn&#x27;t be able to crash OS  an application shouldn&#x27;t be able to <span class="keyword">break</span> out of its isolation  </span>=&gt; need strong isolation between apps <span class="keyword">and</span> OS  approach: hardware support  - user/kernel mode  - <span class="keyword">virtual</span> memory  Processors provide user/kernel mode  kernel mode: can execute <span class="string">&quot;privileged&quot;</span> instructions    e.g., setting kernel/user bit    e.g., reprogramming timer chip  user mode: cannot execute privileged instructions  Run OS in kernel mode, applications in user mode  [RISC-V has also an M mode, which we mostly ignore]Processors provide <span class="keyword">virtual</span> memory  Hardware provides page tables that translate <span class="keyword">virtual</span> address to physical  Define what physical memory an application can access  OS sets up page tables so that each application can access only its memoryApps must be able to communicate with kernel  Write to storage device, which is shared =&gt; must be <span class="keyword">protected</span> =&gt; in kernel  Exit app  ...Solution: add instruction to change mode in controlled way  ecall &lt;n&gt;  enters kernel mode at a pre-agreed entry pointModify OS picture  user / kernel (redline)  app -&gt; <span class="built_in">printf</span>() -&gt; write() -&gt; SYSTEM CALL -&gt; sys_write() -&gt; ...    user-level libraries are app<span class="number">&#x27;</span>s <span class="keyword">private</span> business  kernel internal functions are <span class="keyword">not</span> callable by user    other way of drawing picture:  syscall <span class="number">1</span>  -&gt; system call stub -&gt; kernel entry -&gt; syscall -&gt; fs  syscall <span class="number">2</span>                                                 -&gt; proc  system call stub executes special instruction to enter kernel    hardware switches to kernel mode    but only at an entry point specified by the kernel  syscall need some way to get at arguments of syscall  [syscalls the topic of <span class="keyword">this</span> week<span class="number">&#x27;</span>s lab] Kernel is the Trusted Computing Base (TCB)  Kernel must be <span class="string">&quot;correct&quot;</span>    Bugs in kernel could allow user apps to circumvent kernel/user      Happens often in practice, because kernels are <span class="built_in">complex</span>      See CVEs  Kernel must treat user apps as suspect    User app may trick kernel to <span class="keyword">do</span> the wrong thing    Kernel must check arguments carefully    Setup user/kernel correctly    Etc.  Kernel in charge of separating applications too    One app may <span class="keyword">try</span> to read/write another app<span class="number">&#x27;</span>s memory  =&gt; Requires a security mindset    Any bug in kernel may be a security exploitAside: can one have process isolation WITHOUT h/w-supported  kernel/user mode <span class="keyword">and</span> <span class="keyword">virtual</span> memory?  yes! use a strongly-typed programming language  - For example, see Singularity O/S  the compiler is then the trust computing base (TCB)  but h/w user/kernel mode is the most popular planMonolothic kernel  OS runs in kernel space  Xv6 does <span class="keyword">this</span>.  Linux etc. too.  kernel interface == system call interface  one big program with file system, drivers, &amp;c  - good: easy <span class="keyword">for</span> subsystems to cooperate    one cache shared by file system <span class="keyword">and</span> <span class="keyword">virtual</span> memory  - bad: interactions are <span class="built_in">complex</span>    leads to bugs    no isolation withinMicrokernel design  many OS services run as ordinary user programs    file system in a file server  kernel implements minimal mechanism to run services in user space    processes with memory    inter-process communication (IPC)  kernel interface != system call interface		  - good: more isolation  - bad: may be hard to get good performance  both monolithic <span class="keyword">and</span> microkernel designs widely usedXv6 <span class="keyword">case</span> study  Monolithic kernel    Unix system calls == kernel interface  Source code reflects OS organization (by convention)    user/    apps in user mode    kernel/  code in kernel mode  Kernel has several parts    kernel/defs.h       proc       fs       ..  Goal: read source code <span class="keyword">and</span> understand it (without consulting book)Using xv6  Makefile builds    kernel program    user programs    mkfs  $ make qemu    runs xv6 on qemu    emulates a RISC-V computerBuilding kernel  .c -&gt; gcc -&gt; .s -&gt; .o  \  ....                     ld -&gt; a.out  .c -&gt; gcc -&gt; .s -&gt; .o  /  makefile keeps .<span class="keyword">asm</span> file around <span class="keyword">for</span> binary  see <span class="keyword">for</span> example, kernel/kernel.asmThe RISC-V computer  A very simple board (e.g., no display)  - RISC-V processor with <span class="number">4</span> cores  - RAM (<span class="number">128</span> MB)  - support <span class="keyword">for</span> interrupts (PLIC, CLINT)  - support <span class="keyword">for</span> UART    allows xv6 to talk to console    allows xv6 to read from keyboard  - support <span class="keyword">for</span> e1000 network card (through PCIe)Development <span class="keyword">using</span> Qemu  More convenient than <span class="keyword">using</span> the real hardware  Qemu emulates several RISC-V computers  - we use the <span class="string">&quot;virt&quot;</span> one    https:<span class="comment">//github.com/riscv/riscv-qemu/wiki  - close to the SiFive board (https://www.sifive.com/boards)    but with virtio for diskWhat is &quot;to emulate&quot;?  Qemu is a C program that faithfully implements a RISC-V processor  for (;;) &#123;    read next instructions    decode instruction    execute instruction (updating processor state)  &#125;  [big idea: software = hardware]  Boot xv6 (under gdb)  $ make CPUS=1 qemu-gdb    runs xv6 under gdb (with 1 core)  Qemu starts xv6 in kernel/entry.S (see kernel/kernel.ld)    set breakpoint at _entry      look at instruction      info reg    set breakpoint at main      Walk through main    single step into userinit      Walk through userinit      show proc.h      show allocproc()      show initcode.S/initcode.asm    break forkret()      walk to userret    break syscall      print num      syscalls[num]      exec &quot;/init&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code 4"></a>Code 4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>S081 <span class="number">2020</span> Lecture <span class="number">4</span>: Virtual Memory==* plan:  address spaces  paging hardware  xv6 VM code## Virtual memory overview* today<span class="number">&#x27;</span>s problem:  [user/kernel diagram]  [memory view: diagram with user processes <span class="keyword">and</span> kernel in memory]  suppose the shell has a bug:    sometimes it writes to a random memory address  how can we keep it from wrecking the kernel?    <span class="keyword">and</span> from wrecking other processes?* we want isolated address spaces  each process has its own memory  it can read <span class="keyword">and</span> write its own memory  it cannot read <span class="keyword">or</span> write anything <span class="keyword">else</span>  challenge:     how to multiplex several memories over one physical memory?	<span class="keyword">while</span> maintaining isolation between memories* xv6 uses RISC-V<span class="number">&#x27;</span>s paging hardware to implement AS<span class="number">&#x27;</span>s  ask questions! <span class="keyword">this</span> material is important  topic of next lab (<span class="keyword">and</span> shows up in several other <span class="built_in">labs</span>)* paging provides a level of indirection <span class="keyword">for</span> addressing  CPU -&gt; MMU -&gt; RAM      VA     PA  s/w can only ld/st to <span class="keyword">virtual</span> addresses, <span class="keyword">not</span> physical  kernel tells MMU how to <span class="built_in">map</span> each <span class="keyword">virtual</span> address to a physical address    MMU essentially has a table, indexed by va, yielding pa    called a <span class="string">&quot;page table&quot;</span>    one page table per address space  MMU can <span class="keyword">restrict</span> what <span class="keyword">virtual</span> addresses user code can use  By programming the MMU, the kernel has complete control over va-&gt;pa mapping    Allows <span class="keyword">for</span> many interesting OS features/tricks* RISC-V maps <span class="number">4</span>-KB <span class="string">&quot;pages&quot;</span>  <span class="keyword">and</span> aligned -- start on <span class="number">4</span> KB boundaries  <span class="number">4</span> KB = <span class="number">12</span> bits  the RISC-V used in xv6 has <span class="number">64</span>-bit <span class="keyword">for</span> addresses  thus page table index is top <span class="number">64</span><span class="number">-12</span> = <span class="number">52</span> bits of VA    except that the top <span class="number">25</span> of the top <span class="number">52</span> are unused      no RISC-V has that much memory now      can grow in <span class="built_in">future</span>    so, index is <span class="number">27</span> bits.* MMU translation  see Figure <span class="number">3.1</span> of book  use index bits of VA to find a page table entry (PTE)  construct physical address <span class="keyword">using</span> PPN from PTE + offset of VA  * what is in PTE?  each PTE is <span class="number">64</span> bits, but only <span class="number">54</span> are used  top <span class="number">44</span> bits of PTE are top bits of physical address    <span class="string">&quot;physical page number&quot;</span>  low <span class="number">10</span> bits of PTE flags    Present, Writeable, &amp;c  note: size <span class="keyword">virtual</span> addresses != size physical addresses* where is the page table stored?  in RAM -- MMU loads (<span class="keyword">and</span> stores) PTEs  o/s can read/write PTEs    read/write memory location corresponding to PTEs   * would it be reasonable <span class="keyword">for</span> page table to just be an <span class="built_in">array</span> of PTEs?  how big is it?  <span class="number">2</span>^<span class="number">27</span> is roughly <span class="number">134</span> million  <span class="number">64</span> bits per entry  <span class="number">134</span>*<span class="number">8</span> MB <span class="keyword">for</span> a full page table    wasting roughly <span class="number">1</span>GB per page table    one page table per address space    one address space per application  would waste lots of memory <span class="keyword">for</span> small programs!    you only need mappings <span class="keyword">for</span> a few hundred pages    so the rest of the million entries would be there but <span class="keyword">not</span> needed* RISC-V <span class="number">64</span> uses a <span class="string">&quot;three-level page table&quot;</span> to save space  see figure <span class="number">3.2</span> from book  page directory page (PD)    PD has <span class="number">512</span> PTEs    PTEs point to another PD <span class="keyword">or</span> is a leaf    so <span class="number">512</span>*<span class="number">512</span>*<span class="number">512</span> PTEs in total  PD entries can be invalid    those PTE pages need <span class="keyword">not</span> exist    so a page table <span class="keyword">for</span> a small address space can be small* how does the mmu know where the page table is located in RAM?  satp holds phys address of top PD  pages can be anywhere in RAM -- need <span class="keyword">not</span> be contiguous  rewrite satp when switching to another address space/application* how does RISC-V paging hardware translate a va?  need to find the right PTE  satp <span class="keyword">register</span> points to PA of top/L2 PD  top <span class="number">9</span> bits index L2 PD to get PA of L1 PD  next <span class="number">9</span> bits index L1 PD to get PA of L0 PD  next <span class="number">9</span> bits index L0 PD to get PA of PTE  PPN from PTE + low<span class="number">-12</span> from VA* flags in PTE  V, R, W, X, U  xv6 uses all of them* what <span class="keyword">if</span> V bit <span class="keyword">not</span> <span class="built_in">set</span>? <span class="keyword">or</span> store <span class="keyword">and</span> W bit <span class="keyword">not</span> <span class="built_in">set</span>?  <span class="string">&quot;page fault&quot;</span>  forces transfer to kernel    trap.c in xv6 source  kernel can just produce error, kill process    in xv6: <span class="string">&quot;usertrap(): unexpected scause ... pid=... sepc=... stval=...&quot;</span>  <span class="keyword">or</span> kernel can install a PTE, resume the process    e.g. after loading the page of memory from disk* indirection allows paging h/w to solve many problems  e.g. phys memory doesn<span class="number">&#x27;</span>t have to be contiguous    avoids fragmentation  e.g. lazy allocation (a lab)  e.g. copy-on-write fork (another lab)  many more techniques  topic of next lecture  * Q: why use <span class="keyword">virtual</span> memory in kernel?  it is clearly good to have page tables <span class="keyword">for</span> user processes  but why have a page table <span class="keyword">for</span> the kernel?    could the kernel run with <span class="keyword">using</span> only physical addresses?  top-level answer: yes    most standard kernels <span class="keyword">do</span> use <span class="keyword">virtual</span> addresses  why <span class="keyword">do</span> standard kernels <span class="keyword">do</span> so?    some reasons are lame, some are better, none are fundamental    - the hardware makes it difficult to turn it off	  e.g. on entering a system call, one would have to disable VM    - the kernel itself can benefit from <span class="keyword">virtual</span> addresses      mark text pages X, but data <span class="keyword">not</span> (helps tracking down bugs)      unmap a page below kernel <span class="built_in">stack</span> (helps tracking down bugs)      <span class="built_in">map</span> a page both in user <span class="keyword">and</span> kernel (helps user/kernel transition)## Virtual memory in xv6* kernel page table   See figure <span class="number">3.3</span> of book  simple maping mostly    <span class="built_in">map</span> <span class="keyword">virtual</span> to physical one-on-one  note <span class="keyword">double</span>-mapping of trampoline  note permissions  why <span class="built_in">map</span> devices?* each process has its own address space  <span class="keyword">and</span> its own page table  see figure <span class="number">3.4</span> of book    note: trampoline <span class="keyword">and</span> trapframe aren<span class="number">&#x27;</span>t writable by user process  kernel switches page tables (i.e. sets satp) when switching processes* Q: why <span class="keyword">this</span> address space arrangement?  user <span class="keyword">virtual</span> addresses start at zero    of course user va <span class="number">0</span> maps to different pa <span class="keyword">for</span> each process  <span class="number">16</span>,<span class="number">777</span>,<span class="number">216</span> GB <span class="keyword">for</span> user heap to grow contiguously    but needn<span class="number">&#x27;</span>t have contiguous phys mem -- no fragmentation problem  both kernel <span class="keyword">and</span> user <span class="built_in">map</span> trampoline <span class="keyword">and</span> trapframe page    eases transition user -&gt; kernel <span class="keyword">and</span> back    kernel doesn<span class="number">&#x27;</span>t <span class="built_in">map</span> user applications  <span class="keyword">not</span> easy <span class="keyword">for</span> kernel to r/w user memory    need translate user <span class="keyword">virtual</span> address to kernel <span class="keyword">virtual</span> address    good <span class="keyword">for</span> isolation (see spectre attacks)  easy <span class="keyword">for</span> kernel to r/w physical memory    pa x mapped at va x* Q: does the kernel have to <span class="built_in">map</span> all of phys mem into its <span class="keyword">virtual</span> address space?## Code walk through* setup of kernel address space   kvmmap()  Q: what is address <span class="number">0x10000000</span> (<span class="number">256</span>M)  Q: how much address space does <span class="number">1</span> L2 entry cover? (<span class="number">1</span>G)  Q: how much address space does <span class="number">1</span> L1 entry cover? (<span class="number">2</span>MB)  Q: how much address space does <span class="number">1</span> L0 entry cover? (<span class="number">4096</span>)  print kernel page table  Q: what is size of address space? (<span class="number">512</span>G)  Q: how much memory is used to represent it after <span class="number">1</span>rst kvmmap()? (<span class="number">3</span> pages)  Q: how many entries is CLINT? (<span class="number">16</span> pages)  Q: how many entries is PLIC? (<span class="number">1024</span> pages, two level <span class="number">1</span> PDs)  Q: how many pages is kernel text (<span class="number">8</span> pages)  Q: how many pages is kernel total (<span class="number">128</span>M = <span class="number">64</span> * <span class="number">2</span>MB)  Q: Is trampoline mapped twice? (yes, last entry <span class="keyword">and</span> direct-mapped, entry [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>])  kvminithart();  Q: <span class="function">after executing <span class="title">w_satp</span><span class="params">()</span> why will the next instruction be <span class="title">sfence_vma</span><span class="params">()</span>?	* <span class="title">mappages</span><span class="params">()</span> in vm.c  arguments are top PD, va, size, pa, perm  adds mappings from a range of va&#x27;s to corresponding pa&#x27;s  rounds b/c some uses pass in non-page-aligned addresses  <span class="keyword">for</span> each page-aligned address in the range    call walkpgdir to find address of PTE      need the PTE&#x27;s <span class="title">address</span> <span class="params">(<span class="keyword">not</span> just content)</span> b/c we want to modify    put the desired pa into the PTE    mark PTE as valid w/ PTE_P* <span class="title">walk</span><span class="params">()</span> in vm.c  mimics how the paging h/w finds the PTE <span class="keyword">for</span> an address  PX extracts the 9 bits at Level level  &amp;pagetable[<span class="title">PX</span><span class="params">(level, va)</span>] is the address of the relevant PTE  <span class="keyword">if</span> PTE_V    the relevant page-table page already exists    PTE2PA extracts the PPN from the PDE  <span class="keyword">if</span> <span class="keyword">not</span> PTE_V    alloc a page-table page    fill in pte with <span class="title">PPN</span> <span class="params">(<span class="keyword">using</span> PA2PTE)</span>  now the PTE we want is in the page-table page* <span class="title">procinit</span><span class="params">()</span> in proc.c  alloc a page <span class="keyword">for</span> each kernel <span class="built_in">stack</span> with a guard page* setup user address space  <span class="title">allocproc</span><span class="params">()</span>: allocates empty top-level page table  <span class="title">fork</span><span class="params">()</span>: <span class="title">uvmcopy</span><span class="params">()</span>  <span class="title">exec</span><span class="params">()</span>: replace proc&#x27;s page table with a <span class="keyword">new</span> one    uvmalloc    loadseg  print user page table <span class="keyword">for</span> sh  Q: what is entry 2? * a process calls <span class="title">sbrk</span><span class="params">(n)</span> to ask <span class="keyword">for</span> n more bytes of heap memory  user/umalloc.c calls <span class="title">sbrk</span><span class="params">()</span> to get memory <span class="keyword">for</span> the allocator  each process has a size    kernel adds <span class="keyword">new</span> memory at process&#x27;s end, increases size  <span class="title">sbrk</span><span class="params">()</span> allocates physical <span class="title">memory</span> <span class="params">(RAM)</span>  maps it into the process&#x27;s page table  returns the starting address of the <span class="keyword">new</span> memory* <span class="title">growproc</span><span class="params">()</span> in proc.c  proc-&gt;sz is the process&#x27;s current size  <span class="title">uvmalloc</span><span class="params">()</span> does most of the work  when switching to user space satp will be loaded with updated page table* <span class="title">uvmalloc</span><span class="params">()</span> in vm.c  why PGROUNDUP?  arguments to <span class="title">mappages</span><span class="params">()</span>...</span></span><br></pre></td></tr></table></figure>

<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code 5"></a>Code 5</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>S081/<span class="number">6.828</span> <span class="number">2019</span> Lecture <span class="number">11</span>: RISC-V calling convention, stack frames, <span class="keyword">and</span> gdbC code is compiled to machine instructions.  How does the machine work at a lower level?  How does <span class="keyword">this</span> translation work?  How to interact between C <span class="keyword">and</span> <span class="keyword">asm</span>  Why <span class="keyword">this</span> matters: sometimes need to write code <span class="keyword">not</span> expressible in C    And you need <span class="keyword">this</span> <span class="keyword">for</span> the syscall lab!RISC-V abstract machine  No C-like control flow, no <span class="keyword">concept</span> of variables, types ...  Base ISA: Program counter, <span class="number">32</span> general-<span class="function">purpose <span class="title">registers</span> <span class="params">(x0--x31)</span>reg    | name  | saver  | description-------+-------+--------+------------x0     | zero  |        | hardwired zerox1     | ra    | caller | <span class="keyword">return</span> addressx2     | sp    | callee | stack pointerx3     | gp    |        | global pointerx4     | tp    |        | thread pointerx5-7   | t0-2  | caller | temporary registersx8     | s0/fp | callee | saved <span class="keyword">register</span> / frame pointerx9     | s1    | callee | saved registerx10-11 | a0-1  | caller | function arguments / <span class="keyword">return</span> valuesx12-17 | a2-7  | caller | function argumentsx18-27 | s2-11 | callee | saved registersx28-31 | t3-6  | caller | temporary registerspc     |       |        | program counterRunning example: sum_to(n)  int sum_to(int n) &#123;</span>    <span class="keyword">int</span> acc = <span class="number">0</span>;    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;      acc += i;    &#125;    <span class="keyword">return</span> acc;  &#125;What does <span class="keyword">this</span> look like in assembly code?  # <span class="built_in">sum_to</span>(n)  <span class="meta"># expects argument in a0  # returns result in a0  sum_to:    mv t0, a0          # t0 <span class="meta-string">&lt;- a0    li a0, 0           # a0 &lt;- 0  loop:    add a0, a0, t0     # a0 &lt;- a0 + t0    addi t0, t0, -1    # t0 &lt;- t0 - 1    bnez t0, loop      # if t0 != 0: pc &lt;- loop    retLimited abstractions  No typed, positional arguments  No local variables  Only registersMachine doesn&#x27;t even see assembly code  Sees binary encoding of machine instructions    Each instruction: 16 bits or 32 bits  E.g. `mv t0, a0` is encoded as 0x82aa  Not quite 1-to-1 encoding from asm, but closeHow would another function call sum_to?  main:    li a0, 10          # a0 &lt;- 10    call sum_toWhat are the semantics of call?  call label :=    ra &lt;- pc + 4       ; ra &lt;- address of next instruction    pc &lt;- label        ; jump to labelMachine doesn&#x27;t understand labels  Translated to either pc-relative or absolute jumpsWhat are the semantics of return?  ret :=    pc &lt;- raLet&#x27;s try it out: demo1.S  (gdb) file user/_demo1  (gdb) break main  (gdb) continue  Why does it stop before running demo1?  (gdb) layout split  (gdb) stepi  (gdb) info registers  (gdb) p $a0  (gdb) advance 18  (gdb) si  (gdb) p $a0What if we wanted a function calling another function?  # sum_then_double(n)  # expects argument in a0  # returns result in a0  sum_then_double:    call sum_to    li t0, 2           # t0 &lt;- 2    mul a0, a0, t0     # a0 &lt;- a0 * t0    ret  main:    li a0, 10    call sum_then_doubleLet&#x27;s try it out: demo2.S  We get stuck in an infinite loop  Why: overwrote return address (ra)How to fix: save ra somewhere  In another register? Won&#x27;t work, just defers problem.  Solution: save on stack  sum_then_double:    addi sp, sp, 16    # function prologue:    sd ra, 0(sp)       # make space on stack, save registers    call sum_to    li t0, 2    mul a0, a0, t0    ld ra, 0(sp)       # function epilogue:    addi sp, sp, -16   # restore registers, restore stack pointer    retLet&#x27;s try it out: demo3.S  (gdb) ...  (gdb) nextiSo far, our functions coordinated with each other  This worked because we were writing all the code involved  Could have written it any other way    E.g. passing arguments in t2, getting return value in t3Conventions surrounding this: &quot;calling convention&quot;  How are arguments passed?    a0, a1, ..., a7, rest on stack  How are values returned?    a0, a1  Who saves registers?    Designated as caller or callee saved    Could ra be a callee-saved register?  Our assembly code should follow this convention  C code generated by GCC follows this convention  This means that everyone&#x27;s code can interop, incl C/asm interop  Read: demo4.c / demo4.asm    Can see function prologue, body, epilogue    Why doesn&#x27;t it save ra? Leaf function, not needed    What is going on with s0/fp?      We compiled with -fno-omit-frame-pointerStack                   .                   .      +-&gt;</span>          .      |   +-----------------+   |      |   | return address  |   |      |   |   previous fp ------+      |   | saved registers |      |   | local variables |      |   |       ...       | <span class="meta-string">&lt;-+      |   +-----------------+   |      |   | return address  |   |      +------ previous fp   |   |          | saved registers |   |          | local variables |   |      +-&gt;</span> |       ...       |   |      |   +-----------------+   |      |   | return address  |   |      |   |   previous fp ------+      |   | saved registers |      |   | local variables |      |   |       ...       | <span class="meta-string">&lt;-+      |   +-----------------+   |      |   | return address  |   |      +------ previous fp   |   |          | saved registers |   |          | local variables |   |  $fp --&gt;</span> |       ...       |   |          +-----------------+   |          | return address  |   |          |   previous fp ------+          | saved registers |  $sp --&gt; | local variables |          +-----------------+Demo program: demo5.c  (gdb) break g  (gdb) si  (gdb) si  (gdb) si  (gdb) si  (gdb) p $sp  (gdb) p $fp  (gdb) x/g $fp-16  (gdb) x/g 0x0000000000002fd0-16Stack diagram:          0x2fe0 |          0x2fd8 | <span class="meta-string">&lt;garbage ra&gt;</span>       \          0x2fd0 | <span class="meta-string">&lt;garbage fp&gt;</span>       / stack frame for main          0x2fc8 | ra into main       \  $fp --&gt; 0x2fc0 | 0x0000000000002fe0 / stack frame for f          0x2fb8 | ra into f          \  $sp --&gt; 0x2fb0 | 0x0000000000002fd0 / stack frame for gGDB can automate this reasoning for us  Plus, it can use debug info to reason about leaf functions, etc.  (gdb) backtrace  (gdb) info frame  (gdb) frame 1  (gdb) info frame  (gdb) frame 2  (gdb) info frameCalling C from asm / calling asm from C  Follow calling convention and everything will work out  Write function prototype so C knows how to call assembly  Demo: demo6.c / demo6_asm.S    Why do we use s0/s1 instead of e.g. t0/t1?    (gdb) b sum_squares_to    (gdb) si ...    (gdb) x/4g $sp    (gdb) si ...Inline assemblyStructs  C struct layout rules    Why: misaligned load/store can be slow or unsupported (platform-dependent)  __attribute__((packed))  How to access and manipulate C structs from assembly?    Generally passed by reference    Need to know struct layout    Demo: demo7.c / demo7_asm.SDebugging  examine: inspect memory contents    x/nfu addr      n: count      f: format      u: unit size  step/next/finish    step: next <span class="meta-keyword">line</span> of C code    next: next <span class="meta-keyword">line</span> of C code, skipping over function calls    finish: continue executing until end of current function call  stepi/nexti    stepi: next assembly instruction    nexti: next assembly instruction, skipping over function calls  layout next    steps through layouts  conditional breakpoints    break, only when a condition holds (e.g. variable has a certain value)  watchpoints    break when a memory location changes value  GDB is a very powerful tool    Read the manual for more!    But you probably don<span class="meta-string">&#x27;t need all the fancy features for this classReferences  RISC-V ISA specification: https://riscv.org/specifications/    Contains detailed information  RISC-V ISA Reference: https://rv8.io/isa    Overview of instructions  RISC-V assembly language reference: https://rv8.io/asm    Overview of directives, pseudo-instructions, and more</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Code-6"><a href="#Code-6" class="headerlink" title="Code 6"></a>Code 6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>S081 <span class="number">2020</span> Lecture <span class="number">6</span>: System Call Entry/ExitToday: user -&gt; kernel transition  system calls, faults, interrupts enter the kernel in the same way  important <span class="keyword">for</span> isolation <span class="keyword">and</span> performance  lots of careful design <span class="keyword">and</span> important detailWhat needs to happen when a program makes a system call, e.g. write()?  [CPU | user/kernel diagram]  <span class="function">CPU resources are <span class="built_in">set</span> up <span class="keyword">for</span> user <span class="title">execution</span> <span class="params">(<span class="keyword">not</span> kernel)</span>    32 registers, sp, pc, privilege mode, satp, stvec, sepc, ...  what needs to happen?    save 32 user registers <span class="keyword">and</span> pc    <span class="keyword">switch</span> to supervisor mode    <span class="keyword">switch</span> to kernel page table    <span class="keyword">switch</span> to kernel <span class="built_in">stack</span>    jump to kernel C code  high-level goals    don&#x27;t let user code interfere with user-&gt;kernel transition      e.g. don&#x27;t execute user code in supervisor mode!    transparent to user code -- resume without disturbingToday we&#x27;re focusing on the user/kernel transition  <span class="keyword">and</span> ignoring what the system call implemenation does once in the kernel  but the sys call impl has to be careful <span class="keyword">and</span> secure also!What does the CPU&#x27;s &quot;mode&quot; protect?  i.e. what does switching mode from user to supervisor allow?  supervisor can use CPU control registers:    &#x27;satp -- page table physical address    &#x27;stvec -- ecall jumps here in kernel</span>; points to trampoline    <span class="string">&#x27;sepc -- ecall saves user pc here #错误发生时汇编代码所在位置，可以根据提示来找比如kernel panic就在kernel.asm中找    &#x27;</span>sscratch -- address of <span class="string">&quot;trapframe&quot;</span>  supervisor can use PTEs that have no PTE_U flag  but supervisor has no other powers!    e.g. can<span class="number">&#x27;</span>t use addresses that aren<span class="number">&#x27;</span>t the in page table    so kernel has to carefully <span class="built_in">set</span> things up so it can workpreview:  write()                        write() returns              User  -----------------------------------------------------------------  uservec() in trampoline.<span class="function">S      <span class="title">userret</span><span class="params">()</span> in trampoline.S   Kernel  <span class="title">usertrap</span><span class="params">()</span> in trap.c           <span class="title">usertrapret</span><span class="params">()</span> in trap.c  <span class="title">syscall</span><span class="params">()</span> in syscall.c           ^  <span class="title">sys_write</span><span class="params">()</span> in sysfile.c      ---|let&#x27;s watch an xv6 system call entering/leaving the kernel  xv6 shell writing its $ prompt  sh.c line 137: <span class="title">write</span><span class="params">(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>, <span class="number">2</span>)</span></span>;  user/usys.S line <span class="number">29</span>    <span class="function"><span class="keyword">this</span> is the <span class="title">write</span><span class="params">()</span> function, still in user space  a7 tells the kernel what system call we want -- SYS_write </span>= <span class="number">16</span>  ecall -- triggers the user/kernel transitionlet<span class="number">&#x27;</span>s start by putting a breakpoint on the ecall  user/sh.<span class="function"><span class="keyword">asm</span> says <span class="title">write</span><span class="params">()</span>&#x27;s ecall is at address 0xde6$ make qemu-<span class="title">gdb</span><span class="params">(gdb)</span> b *0<span class="title">xde6</span><span class="params">(gdb)</span> <span class="title">c</span><span class="params">(gdb)</span> <span class="keyword">delete</span> 1<span class="params">(gdb)</span> x/3i 0xde4let&#x27;s look at the <span class="title">registers</span><span class="params">(gdb)</span> print $<span class="title">pc</span><span class="params">(gdb)</span> info reg$pc <span class="keyword">and</span> $sp are at low addresses -- user memory starts at zeroC on RISC-V <span class="built_in">puts</span> function arguments in a0, a1, a2, &amp;<span class="title">cwrite</span><span class="params">()</span> arguments: a0 is fd, a1 is buf, a2 is <span class="title">n</span><span class="params">(gdb)</span> x/2c $a1the shell is printing the $ promptwhat page table is in use?  <span class="params">(gdb)</span> print/x $satp        <span class="keyword">not</span> very useful  qemu: control-a c, info mem    there are mappings <span class="keyword">for</span> six pages    instructions, data, <span class="built_in">stack</span> <span class="title">guard</span> <span class="params">(no PTE_U)</span>, <span class="built_in">stack</span>,    then two high mystery pages: trapframe <span class="keyword">and</span> trampoline    there are no mappings <span class="keyword">for</span> kernel memory, devices, physical memlet&#x27;s execute the <span class="title">ecall</span><span class="params">(gdb)</span> stepiwhere are we?  <span class="params">(gdb)</span> print $pc        we&#x27;re executing at a very high <span class="keyword">virtual</span> <span class="title">address</span>  <span class="params">(gdb)</span> x/6i 0x3ffffff000        these are the instructions we&#x27;re about to execute        see uservec in kernel/trampoline.S        it&#x27;s the start of the kernel&#x27;s trap handling <span class="title">code</span>  <span class="params">(gdb)</span> info reg        the registers hold user <span class="title">values</span> <span class="params">(except $pc)</span>  qemu: info mem        we&#x27;re still <span class="keyword">using</span> the user page table        note that $pc is in the trampoline page, the very last pagewe&#x27;re executing in the &quot;trampoline&quot; page, which contains the start ofthe kernel&#x27;s trap handling code. ecall doesn&#x27;t <span class="keyword">switch</span> page tables, sothese kernel instructions have to exist somewhere in the user pagetable. the trampoline page is the answer: the kernel maps it at thetop of every user page table. the kernel sets $stvec to the trampolinepage&#x27;s <span class="keyword">virtual</span> address. the trampoline is <span class="keyword">protected</span>: no PTE_U flag.<span class="params">(gdb)</span> print/x $stveccan we tell that we&#x27;re in supervisor mode?  I don&#x27;t know a way to find the mode directly  but observe $pc is executing in a page with no PTE_U flag    lack of crash implies we are in supervisor modehow did we get here?  ecall did three things:    <span class="comment">//change mode from user to supervisor    //save $pc in $sepc      (gdb) print/x $sepc    //jump to $stvec (i.e. set $pc to $stvec)      the kernel previously set $stvec, before jumping to user spacenote: ecall lets user code switch to supervisor mode  but the kernel immediately gains control via $stvec //via   so the user program itself can&#x27;t execute as supervisorwhat needs to happen now?  save the 32 user register values (for later transparent resume)  switch to kernel page table  set up stack for kernel C code  jump to kernel C codewhy didn&#x27;t the RISC-V designers have ecall do these things for us?  ecall does as little as possible:  to give O/S designers scope for very fast syscalls / faults / intrs    maybe O/S can handle some traps w/o switching page tables    maybe we can map BOTH user and kernel into a single page table       so no page table switch required    maybe some registers do not have to be saved    maybe no stack is required for simple system callsthere have been many clever schemes invented for kernel entry!  different amounts of work by CPU  different strategies for handler s/w  performance here is often super importantwhat are our options at this point for saving user registers?  can we just write them somewhere convenient in physical memory?    no, even supervisor mode is constrained to use the page table  can we first set satp to the kernel page table?    supervisor mode is allowed to set satp...    but we don&#x27;t know the address of the kernel page table at this point!    and we need a free register to even execute csrw satp, $xxtwo parts to the solution for where to save the 32 user registers:  1) xv6 maps a 2nd kernel page, the trapframe, into every user page table     it has space to hold the saved registers     the kernel gives each process a different trapframe page     the page at 0x3fffffe000 is the trapframe page     see struct trapframe in kernel/proc.h     (but we still need a register holding the trapframe&#x27;s address...)  2) RISC-V provides the sscratch register     the kernel puts a pointer to the trapframe in sscratch       before entering user space     supervisor code can swap any register with sscratch       thus both getting hold of the value in sscratch,       and simultaneously saving the register&#x27;s user value see this at the start of uservec in trapframe.S:&quot;  csrrw a0, sscratch, a0the csrrw has already been executed due to some gdb quirk...(gdb) print/x $a0      address of the trapframe(gdb&gt; print/x $sscratch      0x2, the old first argument (fd)now uservec() has 32 saves of user registers to the trapframe, via a0  so they can be restored later, when the system call returns  let&#x27;s skip them(gdb) b *0x3ffffff076(gdb) cnow we&#x27;re setting up to be able to run C code in the kernelfirst a stack  previously, kernel put a pointer to top of this process&#x27;s    kernel stack in trapframe  look at struct trapframe in kernel/proc.h  &quot;ld sp, 8(a0)&quot; fetches the kernel stack pointer  remember a0 points to the trapframe  at this point the only kernel data the code can    get at is the trapframe, so everything has to be loaded from there.(gdb) stepiretrieve hart ID into tp(gdb) stepiwe want to jump to the kernel C function usertrap(), which  the kernel previously saved in the trapframe.  &quot;ld t0, 16(a0)&quot; fetches it into t0, we&#x27;ll use it in a moment,    after switching to the kernel page table(gdb) stepiload a pointer to the kernel pagetable from the trapframe,and load it into satp, and issue an sfence to clear the TLB.(gdb) stepi(gdb) stepi(gdb) stepiwhy isn&#x27;t there a crash at this point?  after all we just switched page tables while executing!  answer: the trampoline page is mapped at the same virtual address    in the kernel page table as well as every user page table(gdb) print $pcqemu: info memwith the kernel page table we can now use kernel functions and datathe jr t0 is a jump to usertrap() (using t0 retrieved from trapframe)(gdb) print/x $t0(gdb) x/4i $t0(gdb) stepi(gdb) tui enablewe&#x27;re now in usertrap() in kernel/trap.c  various traps come here, e.g. errors, device interrupts, and system calls  usertrap() looks in the scause register to see the trap cause    see Figure 10.3 on page 102 of The RISC-V Reader  scause = 8 is a system call(gdb) next ... until syscall()(gdb) step(gdb) nextnow we&#x27;re in syscall() kernel/syscall.cmyproc() uses tp to retrieve current struct proc *p-&gt;xxx is usually a slot in the current process&#x27;s struct procsyscall() retrieves the system call number from saved register a7  p-&gt;trapframe points to the trapframe, with saved registers  p-&gt;trapframe-&gt;a7 holds 16, SYS_write  p-&gt;trapframe-&gt;a0 holds write() first argument -- fd  p-&gt;trapframe-&gt;a1 holds buf  p-&gt;trapframe-&gt;a2 holds n(gdb) next ...(gdb) print numthen dispatches through syscall[num], a table of functions(gdb) next ...(gdb) stepaha, we&#x27;re in sys_write.at this point system call implementations are fairly ordinary C code.let&#x27;s skip to the end, to see how a system call returns to user space.(gdb) finishnotice that write() produced console output (the shell&#x27;s $ prompt)back to syscall()the p-&gt;tf-&gt;a0 assignment causes (eventually) a0 to hold the return value  the C calling convention on RISC-V puts return values in a0(gdb) nextback to usertrap()(gdb) print p-&gt;trapframe-&gt;a0write() returned 2 -- two characters -- $ and space(gdb) next(gdb) stepnow we&#x27;re in usertrapret(), which starts the process of returning  to the user programwe need to prepare for the next user-&gt;kernel transition  stvec = uservec (the trampoline), for the next ecall  traframe satp = kernel page table, for next uservec  traframe sp = top of kernel stack  trapframe trap = usertrap  trapframe hartid = hartid (in tp)at the end, we&#x27;ll use the RISC-V sret instruction  we need to prepare a few registers that sret uses  sstatus -- set the &quot;previous mode&quot; bit to user  sepc -- the saved user program counter (from trap entry)we&#x27;re going to switch to the user page table while executing  not OK in usertrapret(), since it&#x27;s not mapped in the user page table.  need a page that&#x27;s mapped in both user and kernel page table -- the trampoline.  jump to userret in trampoline.S(gdb) tui disable(gdb) step(gdb) x/8i 0x3ffffff090a0 holds TRAPFRAMEa1 holds user page table addressthe csrw satp switches to the user address space(gdb) stepi(gdb) stepi(gdb) stepithe csrw scratch puts the user a0 into sscratch  just before sret we&#x27;ll do a swap,  so that a0 holds the user a0 and sscratch holds trapframe pointer.  which is what uservec expects.now 32 loads from the trapframe into registers  these restore the user registers  let&#x27;s skip over them(gdb) b *0x3ffffff10a(gdb) chere&#x27;s the csrw that swaps a0 with sscratch(gdb) stepi(gdb) print/x $a0 -- the return value from write()(gdb) print/x $sscratch -- trapframe address for uservecnow we&#x27;re at the sret instruction(gdb) print $pc(gdb) stepi(gdb) print $pcnow we&#x27;re back in the user program ($pc = 0x0xdea)  returning 2 from the write() function(gdb) print/x $a0and we&#x27;re done with a system call!summary  system call entry/exit is far more complex than function call  much of the complexity is due to the requirement for isolation    and the desire for simple and fast hardware mechanisms  a few design questions to ponder:    can an evil program abuse the entry mechanism?    can you think of ways to make the hardware or software simpler?    can you think of ways to make traps faster?</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Code-7"><a href="#Code-7" class="headerlink" title="Code 7"></a>Code 7</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>S081 <span class="number">2020</span> Lecture <span class="number">7</span>: Q&amp;APlan: answering your questions  Approach:    walk through staff solutions    start with pgtbl lab because it was the hardest    your questions are at bottom of <span class="keyword">this</span> filePgtbl lab comments  few lines of code, but difficult-to-debug bugs  - <span class="string">&quot;worst&quot;</span> <span class="keyword">case</span>: qemu/xv6 stops running  - <span class="string">&quot;best&quot;</span> <span class="keyword">case</span>: kernel panic  hard to debug <span class="keyword">for</span> staff too  - there are so many possible reasons why  - you discovered once we hadn<span class="number">&#x27;</span>t seen yet  likely to be the most challenging lab  - historically the first VM lab is hard  - <span class="keyword">this</span> year too, even though we made a <span class="keyword">new</span> lab to provide a gentler intro to VMPart <span class="number">1</span> of pgtbl lab  Explain vm output in terms of fig <span class="number">3</span><span class="number">-4</span>   page table <span class="number">0x0000000087f67000</span>    .<span class="number">.0</span>: pte <span class="number">0x0000000021fd8c01</span> pa <span class="number">0x0000000087f63000</span> fl <span class="number">0x0000000000000001</span>    .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fd8801</span> pa <span class="number">0x0000000087f62000</span> fl <span class="number">0x0000000000000001</span>    .. .. .<span class="number">.0</span>: pte <span class="number">0x0000000021fd901f</span> pa <span class="number">0x0000000087f64000</span> fl <span class="number">0x000000000000001f</span>    .. .. .<span class="number">.1</span>: pte <span class="number">0x0000000021fd840f</span> pa <span class="number">0x0000000087f61000</span> fl <span class="number">0x000000000000000f</span>    .. .. .<span class="number">.2</span>: pte <span class="number">0x0000000021fd801f</span> pa <span class="number">0x0000000087f60000</span> fl <span class="number">0x000000000000001f</span>    .<span class="number">.255</span>: pte <span class="number">0x0000000021fd9801</span> pa <span class="number">0x0000000087f66000</span> fl <span class="number">0x0000000000000001</span>    .. .<span class="number">.511</span>: pte <span class="number">0x0000000021fd9401</span> pa <span class="number">0x0000000087f65000</span> fl <span class="number">0x0000000000000001</span> <span class="comment">//trampoline    .. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000 fl 0x0000000000000007	//trapframe    .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 fl 0x000000000000000b    what is entry 0, 1, and 2?    what is 510 and 511?    - 511: trampoline    - 510: trapframe    why are the protection bits as they are?    - 510: RWV    - 511: XV    - 1: no U    are the physical addresses contiguous?Part 2 of pgtbl lab  Add a kernel page table to each process in prep for Part 3  - exact copy of *the* kernel_pagetable    How hard can this be?  hard! some reasons:  - xv6 code specialized to one kernel page table    no kvmcreate_page_table()  - kvminit() isn&#x27;t the full story    also mappings in procinit(), and virtio_disk.c  - cleanup must be done care    don&#x27;t free kernel stacks  - easy to make a small error    even small errors are time consuming     Two possible approaches to part II  1) generalize kvminit()    create a new per-process kernel page table  2) share kernel_pagetable    make the per-process kernel page table share much with kernel_pagetable    - my solutions takes approach 2; other staff members too approach 1    - i took approach 2 mostly out of &quot;laziness&quot;      don&#x27;t have to think too hard what is in the kernel_pagetable      didn&#x27;t want to write much code      - not sure it is shorter, though      approach 2 has some benefits I didn&#x27;t realize      - avoided certain class of bugs (e.g., kernel stacks)        Implementation approach:    small incremental baby steps    keep existing code working  allows comparing old and new easily  allows rolling back easily  Approach 2  - kvmcreate()    copy entries 1..512    add a few devices that live in 0    - anything below 1G (i.e., all devices)  - kvmfree()    only entry 0 is worth considering    just need to free intermediate pages (see 3-level pic)    a bit ugly    where to call kvmfree()    - exit()?    - freeproc()? - scheduler() - usertrapret()Part 3 of pgtbl lab  map user pgtbl of process into bottom of process&#x27;s kernel page table  - draw figure  why? convenient for kernel programmers  - can replace copyin with copy_new()  copyin_new is just a memmove(), avoid the walkaddr()&#x27;s  - hardware can do the walks for us  mapping user page tables into kernel page table  - kvmmapuser()    copies upte into kpte, adjust permissions  Using kvmmapuser():  - userinit()  - exec()   no need to replace kernel page table  - fork()  - sbrk()    memmove()  - why the checks before the memmove()?  - what does each case coverSyscall lab  systems calls look like functions calls  BUT they are not function calls  - U/K boundary transition  user/usys.pl  - generates stubs for stubs  kernel/syscall.c  - demultiplexes system calls  trace  - proc.h  - fork()  sysinfo  - copyout()Util lab  primes  - close fd&#x27;s to terminate correctly  xargs  - setting up argv    === Questions ===HW===In the page table lab, the kernel&#x27;s hardware address translator won&#x27;tallow kernel to dereference user pages. More specifically, if the pagetable entry has &quot;PTE_U&quot; bit set, which means user can access it, thenkernel won&#x27;t be able to access it through the hardware addresstranslator unless we set &quot;PTE_U&quot; to false in the per-process kernelpage table. Is there a specific reason for this?===Why is the kernel not allowed to read memory mapped with the PTE_Uflag? To prevent malicious memory from being read?===In the last lecture, it was mentioned that even the kernel insupervisor mode could not directly edit anything and everything in thememory. The kernel accesses memory through the kernel page table, andthus is limited. However, couldn&#x27;t the kernel just set the satpregister to 0, and then there is no MMU translation, the CPU directlyaccesses physical addresses. Could that situation not arise? Thatcertainly the case before page tables are set up and paging isenabled.===A minor question: why the specific order of the trapframe in proc.h(t0..t2, then s0, s1, a0..a7, s2..s11)?===PGTBL LABI&#x27;m confused why the kernel can directly dereference the pointer inpart 3 of pagetable because we have now mapped the user&#x27;s virtualaddress into the user&#x27;s kernel pagetable. Since it is still a virtualaddress, doesn&#x27;t it need to just walk the user&#x27;s kernel page table? Oris it because the user code now enters the kernel, and the kernel&#x27;spagetable directly maps virtual addresses to physical addressses?However, in my implementation, it seems to be that the kernel stillmaps the same virtual addresses to the same physical addresses as theuser&#x27;s page table, , which is not a direct mapping.===In the pgtbl lab, during Part 3 (copyin), I ran into an interestingbug while changing a process&#x27;s user mappings. In fork(), I was callingmy helper function to copy the user mappings from the process&#x27;s userpage table to its kernel page table. When I tried to copy the parentprocess&#x27;s user page table, running &quot;usertests&quot; in the xv6 kernel justcaused it to return and none of the tests were run. However, copyingthe child&#x27;s user page table worked. Shouldn&#x27;t either instruction beok, since the child&#x27;s user page table was just copied over from theparent?===For the page tables lab, what was the correct way to copy and changethe process&#x27;s kernel page table the same way in fork(), exec(), andsbrk()? I tried to copy over a range of entries from the process&#x27;spage table into the process&#x27;s kernel page table directly, but my codewas panicking when trying to use mappages() after my change to the 3functions.===If xv6 was written with the modifications from the pgtbl lab, we wouldnot need to worry about switching the pagetables in the tramplinecode, right? Would there even be a need for the trampoline code to bemapped in the user pages? My understanding was that that code can bemapped in the per-process kernel pgtbls and be used from there duringthe trap handling. I was also curious about why when a PTE has thePTE_U bit is set, code in supervisor mode cannot access that pagetable. It is confusing to me because I thought that the kernel has thewhole memory mapped and it can modify any virtual address even if someuser data lives there. In the last lab, we could even know the exactva that the user pgtbl has for each of the pa that it uses and I thinkmaybe be able to corrupt user&#x27;s data.===Is there a more efficient way to free each process&#x27;s kernel pagetable?I basically copied the freewalk function and removed the panic forleaves.  Although this seemed fast enough for the tests, it stillseemed a little slow.  When I tried to optimize it by reducingrecursion depth, I ran into troubles.  Overall, this seems like acomputationally intensive task, especially if all physical memory ismapped in the kernel pagetable for all processes. I was a littleworried about breaking something, but could I have stopped mapping allphysical memory?===Do operating systems using hierarchical pagetables ever set up the pagetablepages so that the lower parts of the hierachy are (atleast in part) shared?===For the pagetable lab, I was trying to implementcopyin/copyinstr. However, I got stuck in an infinite loop with thescheduler because the scheduler seemed to have no process that needsto be run. I am curious as to what could happen to the pagetable sothat the OS would stop a process from running (especially the mainprocess). What part of the code does the operating system set thestate of a process to not running if the pagetable is broken?===I don&#x27;t understand why when I movedw_satp(MAKE_SATP(kernel_pagetable));sfence_vma();outside ofif(found == 0) &#123;  intr_on();  asm volatile(&quot;wfi&quot;);&#125;in scheduler that everything in part 2 of the page table labworked. Because before then, it worked to a certain degree, wheresometimes it&#x27;d pass and sometimes it&#x27;d fail.===In the pagetable lab, is there a significant impact on performancefrom copying to per-process kernel page tables so frequently? If so,how does this balance out with the improvements that come from beingable to directly de-reference user address in kernel space?===How are pipes implemented in xv6, and how would the changes to thepage tables implemented in the pgtbl lab effect this implementation?Do the per-process page tables hinder each process&#x27; ability tocommunicate with each other?===1. Why did uvmfree/freewalk originally panic at a leaf, and why did we need tochange that.2. Why does the inclusion of the user PTE_U bit not allow the kernel to accessthe PTE?===The lab mentioned that &quot;the goal of this section and the next is toallow the kernel to directly dereference user pointers.&quot; However, Ididn&#x27;t understand how this adds functionality to the kernel, or whythis is an important function for the kernel to be able to do.===For the page table lab, I had some questions on access rights. If theuser bit is set, does that mean in user mode both read/write/executeoptions can be performed, or can only read/write/execute be done inkernel mode?Also, are there pages in the kernel page table accessible in user mode?===In the pgtbl lab, we added kernel pagetables to each process in orderto simplify reading userspace pointers. Was there any reason wecouldn&#x27;t do the same for copying data out to userspace? I think you&#x27;dhave to be a little careful in exec(), since copyout is used therewhile setting up the process, but apart from that?Also, one of the challenge exercises for that lab is to remove thePLIC limit.  How would you do that--set up a new pagetable for PLICaccess, and switch to that when trying to access PLIC registers?===I was talking to some friends who solved the pagetable part 3 by usinga modified uvmcopy but they needed to limit the pages they werecopying to pass the runtime limit. What&#x27;s taking so long in thatfunction? Does the walking make the copy function less optimized forthe job?===Question: About the page table lab, when I was debugging my code, Irealized for reparent test, I sometimes pass it but I sometimesfail. I fixed this issue by realizing I need to switch back tokernel_pagetable in the scheduler after exiting the process&#x27;s kernalpagetable. I wonder why such mistakes would cause reparent to behavenon-deterministaclly? Was there some sort of race condition?===In our &quot;copy user page table to kernel page table&quot; functions in thepagetable lab, why was it necessary to panic when a pagetable entrydidn&#x27;t exist or was not valid for a given virtual address? Whycouldn&#x27;t we have just skipped that virtual address? More broadly, howcould we assume that all of the user page table values that we werecopying over were present and valid?===It really messes with my head that you have to define a C function forallocating memory (kalloc). This is one of the first things xv6 doesin main.c, directly after which it creates the kernel page table(using a call to kalloc). Given the way kalloc works, is the kernelpage table always going to be at the &quot;end&quot; address in the kernel&#x27;svirtual memory space since its the first piece of memory to beallocated? And do you have to be careful about using memory prior tocalling kinit in main.c?===This question is regarding the pgtbl lab. I had some confusion aboutthe exact motivation for the lab, specifically creating a separatekernel page table for each process. I wasn&#x27;t sure what the lab meantby &quot;directly dereferencing the user address&quot;. From my understanding,what the kernel currently does to translate the virtual address of theuser process is to &quot;walk&quot; down the user pagetable.So if you essentially combine the kernel page table and user pagetables, wouldn&#x27;t you still &quot;walk&quot; down the new per-process kernel pagetable to get the physical address? I don&#x27;t understand how this changesanything since the two approaches differ only in which page table thekernel is walking down.===For question 1 in the page table lab, was page 1 the guard page? Thismade sense to me since it has the user flag off so it would causeerrors if the user tried to access it. However I believe the textbooksaid that the guard page will have its valid bit off in which case itwould not show up in vmprint.====Why does the initial page table ( as printed in vmprint ) have indices0 and 255?I deduced that these pages should eventually point towardsthe initial user program data ( text, guard page and stack ) and thetrampoline/trapframe respectively. However, the trampoline should beat the very top of the virtual address space, so it should have thehighest possible virtual address. Therefore, shouldn&#x27;t the root pagetable contain pages 0 and 511 rather than 0 and 255?====VM IN GENERAL====How was copyin with per process kernel pagetables exploited, asmentioned in the pgtbl lab?===This is less of a question, but I&#x27;d love to hear more about how Xv6 compares tovarious other operating systems that we might use in our day-to-day lives.I don&#x27;t have specific questions, but for example:- How does Linux set up its page tables? The lab mentioned this may have  changed with Spectre/Meltdown, but what do they do now?- Do we know how pages/traps are handled in Windows or macOS, or what tradeoffs  were made in the design decisions there? I read somewhere that Windows XP  source code leaked - did we learn anything interesting from that, or does  Microsoft just use standard techniques?- Does x86-64 have instructions that significantly simplify or combine or  increase performance of particular parts of the pagetable or traps chain of  code in interesting ways?- How active is the development of OS techniques like syscalls, pagetables,  etc.? Are they mostly considered a &quot;solved&quot; problem by modern operating  systems and only really experimented on in research?===SYSCALL LAB===Could you possibly walk through the roles of the different places wehad to update when we added a new system call? (e.g. user/user.h,user/usys.pl, kernel/syscall.h, and a few others)I&#x27;m mostly wondering (1) in what order these are visited when the codeis compiled and (2) why there isn&#x27;t a more centralized way to do this?For example, in kernel/syscall.c, why do we need to manually edit boththe extern list and the syscalls array beneath it?===UTIL LAB===One of the challenges for the first lab was to add history/tabcompletion. However, one thing that gave me some trouble was beingable to parse single keystrokes (namely the arrow keys). Is there away to read a single character (not having to press enter)?</span></span><br></pre></td></tr></table></figure>

<h3 id="Code-8"><a href="#Code-8" class="headerlink" title="Code 8"></a>Code 8</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.828</span> <span class="number">2016</span> Lecture <span class="number">8</span>: Page faults==* plan: cool things you can <span class="keyword">do</span> with vm  - Better performance/efficiency    e.g., one zero-filled page    e.g., copy-on-write fork  - New features    e.g., memory-mapped files  * <span class="keyword">virtual</span> memory: several views  * primary purpose: isolation    each process has its own address space  * Virtual memory provides a level-of-indirection    provides kernel with opportunity to <span class="keyword">do</span> cool stuff	already some examples:	- shared trampoline page	- guard page	but more possible...	* Key idea: change page tables on page fault  Page fault is a form of a <span class="built_in">trap</span> (like a system call)  Xv6 panics on page fault    But you don<span class="number">&#x27;</span>t have to panic!  Instead:    update page table instead of panic	restart <span class="built_in">instruction</span> (see <span class="built_in">userret</span>() from traps lecture)  Combination of page faults <span class="keyword">and</span> updating page table is powerful!	* RISC-V page faults  <span class="number">3</span> of <span class="number">16</span> exceptions are related to paging  Exceptions cause controlled transfers to kernel    See traps lecture	* Information we might need at page fault to <span class="keyword">do</span> something interesting:  <span class="number">1</span>) The <span class="keyword">virtual</span> address that caused the fault    See stval <span class="keyword">register</span>; page faults set it to the fault address  <span class="number">2</span>) <span class="function">The type of violation that caused the fault    See scause <span class="keyword">register</span> <span class="title">value</span> <span class="params">(instruction, load, <span class="keyword">and</span> Store page fault)</span>  3) The instruction <span class="keyword">and</span> mode where the fault occurred    User IP: tf-&gt;epc    U/K mode: implicit in usertrap/kerneltrap  * lazy/on-demand page allocation  * sbrk() is old fashioned;</span>    applications often ask <span class="keyword">for</span> memory they need    - <span class="keyword">for</span> example, the allocate <span class="keyword">for</span> the largest possible input but      an application will typically use less    <span class="keyword">if</span> they ask <span class="keyword">for</span> much, <span class="built_in">sbrk</span>() could be expensive    - <span class="keyword">for</span> example, <span class="keyword">if</span> all memory is in use, have to wait until      kernel has evicted some pages to free up memory    sbrk allocates memory that may never be used.  * moderns OSes allocate memory lazily    plan:      allocate physical memory when application needs it      adjust p-&gt;sz on sbrk, but don<span class="number">&#x27;</span>t allocate      when application uses that memory, it will result in page fault      on pagefault allocate memory      resume at the fault instruction    may use less memory      <span class="keyword">if</span> <span class="keyword">not</span> used, no fault, <span class="function">no allocation    spreads the cost of allocation over the page faults instead    of upfront in <span class="title">sbrk</span><span class="params">()</span>  * demo    modify sysproc.c    modify trap.c    modify vm.c* one zero-filled <span class="title">page</span> <span class="params">(zero fill on demand)</span>  * applications often have large part of memory that must zero    global arrays, etc.    the &quot;block starting symbol&quot; <span class="params">(bbs)</span> segment  * thus, kernel must often fill a page with zeros  * idea: memset *one* page with zeros    map that page copy-on-write when kernel needs zero-filled page    on write make copy of page and map it read/write in app address space* copy-on-write fork  * observation:    xv6 fork copies all pages from parent (see fork())    but fork is often immediately followed by exec  * idea: share address space between parent and child    modify fork() to map pages copy-on-write      use extra available system bits (RSW) in PTEs    on page fault, make copy of page and map it read/write* demand paging  * observation: exec loads the complete file into memory (see exec.c)    expensive: takes time to do so (e.g., file is stored on a slow disk)    unnecessary: maybe not the whole file will be used  * idea: load pages from the file on demand    allocate page table entries, but mark them on-demand    on fault, read the page in from the file and update page table entry    need to keep some meta information about where a page is located on disk      this information is typically in structure called virtual memory area (VMA)  * challenge: file larger than physical memory (see next idea)* use virtual memory larger than physical memory  * observation: application may need more memory than there is physical memory  * idea: store less-frequently used parts of the address space on disk    page-in and page-out pages of the address address space transparently  * works when working sets fits in physical memory    most popular replacement strategy: least-recently used (LRU)    the A(cess) bit in the PTE helps the kernel implementing LRU  * demo: run top and vmstat    on laptop and dialup.athena.mit.edu    see VIRT RES MEM SHR columns  * memory-mapped files  * idea: allow access to files using load and store    can easily read and writes part of a file    e.g., don<span class="string">&#x27;t have to change offset using lseek system call  * Unix systems a new system call for m-mapped files:    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);  * kernel page-in pages of a file on demand    when memory is full, page-out pages of a file that are not frequently used* shared virtual memory  * idea: allow processes on different machines to share virtual memory    gives the illusion of physical shared memory, across a network  * replicate pages that are only read  * invalidate copies on write  * TLB management  CPUs caches paging translation for speed  xv6 flushes entire TLB during user/kernel transitions    why?  RISC-V allows more sophisticated plans    * PTE_G: global TLB bits      what page could use this?    * ASID numbers      TLB entries are tagged with ASID, so kernel can flush selectively      SATP takes an ASID number      sfence.vma also takes an ASID number    * Large pages      2MB and 1GB* Virtual memory is still evolving  Recent changes in Linux    PKTI to handle meltdown side-channel      (https://en.wikipedia.org/wiki/Kernel_page-table_isolation)    xv6 basically implements KPTI  Somewhat recent changes    Support for 5-level page tables (57 address bits!)    Support for ASIDs  Less recent changes    Support for large pages    NX (No eXecute) PTE_X flag--- COW in Linuxhttps://lwn.net/Articles/849876/</span></span></span><br></pre></td></tr></table></figure>



<h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3><p>页表(page table)：管理虚拟内存页和物理内存页映射和缓存状态的数据结构</p>
<p>页表条目(page table entry PTE)：是构成页表的基本元素，是索引号为虚拟页号、值为物理页号的数组</p>
<p>地址翻译：将虚拟地址映射成物理地址的过程</p>
<p>页(page)：和存储里块一样，类似的单位；虚拟内存中使用页(<strong>page</strong>)来表示block</p>
<p>页表基地址寄存器（PTBR）：CPU有一个专门的页表基地址寄存器，指向当前页表的基地址</p>
<p>翻译后备缓冲区（TLB）：一个用来<strong>缓存页表条目PTE</strong>的硬件设备</p>
<p>MMU(Memory Management Unit)：CPU中含有的硬件，将虚拟地址转换为物理地址</p>
<ul>
<li>对于CPU来说，它的目标存储器是<strong>物理内存</strong>，使用cache做物理内存的缓存</li>
<li>对于虚拟内存来说，它的目标存储器是磁盘空间，使用物理内存做磁盘的缓存</li>
</ul>
<p>虚拟内存就是中间层的存在.</p>
<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><ul>
<li>首先用 <code>tmux</code> 开两个终端窗口。</li>
<li>第一个窗口键入<code>make CPUS=1 qemu-gdb</code>.  这里的CPUS&#x3D;1就是使用一个CPU核，<code>-smp 1</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">terminal 1(base) ➜  xv6-labs-2020 git:(util) ✗ make CPUS=1 qemu-gdb *** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25501</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改自己 <code>home</code> 目录下的 <code>.gdbinit</code> 文件，允许 <code>gdb</code> 在<code>xv6-labs-2020</code>这个目录启动的时候，加载该文件夹下的 <code>.gdbinit</code> 文件。</li>
<li>启动：riscv64-unknown-elf-gdb</li>
<li>远程连接GDB server ：target remote localhost:25501</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">terminal 2(base) ➜  xv6-labs-2020 git:(util) ✗<span class="built_in">echo</span> <span class="string">&quot;add-auto-load-safe-path YOUR_PATH/xv6-labs-2020/.gdbinit &quot;</span> &gt;&gt; ~/.gdbinit(base) ➜  xv6-labs-2020 git:(util) ✗ riscv64-unknown-elf-gdbGNU gdb (GDB) 10.1Copyright (C) 2020 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.This GDB was configured as <span class="string">&quot;--host=arm-apple-darwin21.1.0 --target=riscv64-unknown-elf&quot;</span>.Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.For bug reporting instructions, please see:&lt;https://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>.warning: File <span class="string">&quot;/Users/zjuchy/S081/xv6-labs-2020/.gdbinit&quot;</span> auto-loading has been declined by your `auto-load safe-path<span class="string">&#x27; set to &quot;$debugdir:$datadir/auto-load&quot;.To enable execution of this file add        add-auto-load-safe-path /Users/zjuchy/S081/xv6-labs-2020/.gdbinitline to your configuration file &quot;/Users/zjuchy/.gdbinit&quot;.To completely disable this security protection add        set auto-load safe-path /line to your configuration file &quot;/Users/zjuchy/.gdbinit&quot;.For more information about this security protection see the&quot;Auto-loading safe path&quot; section in the GDB manual.  E.g., run from the shell:        info &quot;(gdb)Auto-loading safe path&quot;(gdb) target remote localhost:25501 Remote debugging using localhost:25501warning: No executable has been specified and target does not supportdetermining executable automatically.  Try using the &quot;file&quot; command.0x0000000000001000 in ?? ()(gdb) file kernel/kernel(gdb) b _entry(gdb) c</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看断点(gdb)info b<span class="comment">#查看线程(gdb)info threads#删除该处所有断点(gdb)delete _entry#删除n号断点(gdb)delete nlayout splitlayout asmlayout reg(gdb) n (gdb) s(gdb) c(gdb) tui enable#tui enable 可以打开源代码展示窗口</span></span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Haoyang Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://zjuchy.github.io/2022/02/02/S081/">https://zjuchy.github.io/2022/02/02/S081/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/02/02/rLZKxailymv5bCH.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/03/Daily/"><img class="prev-cover" src="https://s2.loli.net/2022/02/02/oJiXKmjqWT5Qk9n.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Daily</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/02/Leetcode/"><img class="next-cover" src="https://s2.loli.net/2022/02/02/oJiXKmjqWT5Qk9n.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Leetcode</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Haoyang Chen</div><div class="author-info__description">I'm a ZJUer, welcome to contact me!</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zjuchy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zjuchy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3190102984@zju.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Note"><span class="toc-number">1.</span> <span class="toc-text">Note</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lec-3"><span class="toc-number">1.1.</span> <span class="toc-text">Lec 3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OS-organization"><span class="toc-number">1.1.1.</span> <span class="toc-text">OS organization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Isolation"><span class="toc-number">1.1.2.</span> <span class="toc-text">Isolation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Unix-interface"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Unix interface</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel-x2F-user-mode"><span class="toc-number">1.1.3.</span> <span class="toc-text">Kernel&#x2F;user mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Table-virtual-memory"><span class="toc-number">1.1.4.</span> <span class="toc-text">Page Table(virtual memory)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Entering-Kernel"><span class="toc-number">1.1.5.</span> <span class="toc-text">Entering Kernel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monolithic-Kernel-Design"><span class="toc-number">1.1.6.</span> <span class="toc-text">Monolithic Kernel Design</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Micro-Kernel-Design"><span class="toc-number">1.1.7.</span> <span class="toc-text">Micro Kernel Design</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xv6-and-qemu"><span class="toc-number">1.1.8.</span> <span class="toc-text">Xv6 and qemu</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lec-4"><span class="toc-number">1.2.</span> <span class="toc-text">Lec 4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Address-Spaces"><span class="toc-number">1.2.1.</span> <span class="toc-text">Address Spaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Table-RISC-V"><span class="toc-number">1.2.2.</span> <span class="toc-text">Page Table(RISC-V)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Translation-Lookaside-Buffer"><span class="toc-number">1.2.3.</span> <span class="toc-text">Translation Lookaside Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trampoline"><span class="toc-number">1.2.4.</span> <span class="toc-text">trampoline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xv6-vmcode-layout"><span class="toc-number">1.2.5.</span> <span class="toc-text">xv6 vmcode+layout</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lec-5"><span class="toc-number">1.3.</span> <span class="toc-text">Lec 5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tui"><span class="toc-number">1.3.1.</span> <span class="toc-text">tui</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#info"><span class="toc-number">1.3.2.</span> <span class="toc-text">info</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reg"><span class="toc-number">1.3.3.</span> <span class="toc-text">reg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-number">1.3.4.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct"><span class="toc-number">1.3.5.</span> <span class="toc-text">struct</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lec-6"><span class="toc-number">1.4.</span> <span class="toc-text">Lec 6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Trap"><span class="toc-number">1.4.1.</span> <span class="toc-text">Trap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#supervisor-mode"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">supervisor mode</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Process-of-Trap"><span class="toc-number">1.4.2.</span> <span class="toc-text">Process of Trap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#before-ecall"><span class="toc-number">1.4.3.</span> <span class="toc-text">before ecall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#after-ecall"><span class="toc-number">1.4.4.</span> <span class="toc-text">after ecall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uservec"><span class="toc-number">1.4.5.</span> <span class="toc-text">uservec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csrrw"><span class="toc-number">1.4.6.</span> <span class="toc-text">csrrw</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Let-8"><span class="toc-number">1.5.</span> <span class="toc-text">Let 8</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code"><span class="toc-number">2.</span> <span class="toc-text">Code</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-3"><span class="toc-number">2.1.</span> <span class="toc-text">Code 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-4"><span class="toc-number">2.2.</span> <span class="toc-text">Code 4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-5"><span class="toc-number">2.3.</span> <span class="toc-text">Code 5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-6"><span class="toc-number">2.4.</span> <span class="toc-text">Code 6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-7"><span class="toc-number">2.5.</span> <span class="toc-text">Code 7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Code-8"><span class="toc-number">2.6.</span> <span class="toc-text">Code 8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VM"><span class="toc-number">2.7.</span> <span class="toc-text">VM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab"><span class="toc-number">3.</span> <span class="toc-text">Lab</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB"><span class="toc-number">3.1.</span> <span class="toc-text">GDB</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/23/CV/" title="CV">CV</a><time datetime="2022-02-23T05:31:01.000Z" title="Created 2022-02-23 13:31:01">2022-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/17/Data-Structure/" title="Data_Structure">Data_Structure</a><time datetime="2022-02-17T03:13:35.000Z" title="Created 2022-02-17 11:13:35">2022-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/09/IMPORTANT/" title="IMPORTANT">IMPORTANT</a><time datetime="2022-02-09T14:43:05.000Z" title="Created 2022-02-09 22:43:05">2022-02-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/03/Daily/" title="Daily">Daily</a><time datetime="2022-02-03T14:10:41.000Z" title="Created 2022-02-03 22:10:41">2022-02-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/02/S081/" title="S081">S081</a><time datetime="2022-02-02T11:59:02.000Z" title="Created 2022-02-02 19:59:02">2022-02-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Haoyang Chen</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>